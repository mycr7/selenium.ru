---
layout: page
title: И ещё раз о том, как "правильно" запускать браузер
joomla_id: 112
joomla_url: webdriverfactory
date: 2014-05-07 12:01:17.000000000 +04:00
author: Алексей Баранцев
excerpt: Примерно раз в год я пишу статью про то, «как правильно запускать браузер» :)
  Но эта, надеюсь, будет последняя в серии. Небольшая предыстория. Давным-давно, в 2010 году на конференции SeleniumCamp я рассказывал про оптимизацию скорости выполнения тестов, и одна из первых рекомендаций была «используйте уже запущенный браузер повторно, не перезапускайте его для каждого теста заново». Потому что запуск браузера — весьма длительная и ресурсоёмкая операция. Чуть позже, уже в 2011 году, я написал первую статью, в которой я изложил «теоретические основы науки о запуске браузеров». Через год после этого появилась вторая статья, в которой описывалась конкретная реализация утилиты, управляющей запущенными браузерами. К ней, естественно, прилагался проект с программным кодом этой утилиты. Ещё через год я наконец выложил усовершенствованный вариант этой утилиты на GitHub, и вот теперь пришло время написать сопроводительную документацию.
category: Статьи
---
<p>Примерно раз в год я пишу статью про то, «как правильно запускать браузер» :)</p>
<p>Но эта, надеюсь, будет последняя в серии.</p>
<p>Небольшая предыстория. Давным-давно, в 2010 году на конференции SeleniumCamp я рассказывал про оптимизацию скорости выполнения тестов, и одна из первых рекомендаций была «используйте уже запущенный браузер повторно, не перезапускайте его для каждого теста заново». Потому что запуск браузера — весьма длительная и ресурсоёмкая операция. Чуть позже, уже в 2011 году, я написал <a href="articles/65-how-to-start-browser-in-theory.html">первую статью</a>, в которой я изложил «теоретические основы науки о запуске браузеров». Через год после этого появилась <a href="articles/66-how-to-start-browser-with-driver-factory.html">вторая статья</a>, в которой описывалась конкретная реализация утилиты, управляющей запущенными браузерами. К ней, естественно, прилагался проект с программным кодом этой утилиты. Ещё через год я наконец выложил усовершенствованный вариант этой утилиты на <a href="https://github.com/barancev/webdriver-factory/">GitHub</a>, и вот теперь пришло время написать сопроводительную документацию.</p>
<p>Итак, встречайте, <strong>новая улучшенная реализация WebDriverFactory</strong>, теперь <span style="text-decoration: line-through;">на всех экранах страны</span> <a href="https://github.com/barancev/webdriver-factory/">на GitHub</a> и <a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22ru.stqa.selenium%22%20AND%20a%3A%22webdriver-factory%22">в центральном репозитории Maven</a>!</p><p><span style="font-family: Arial, Helvetica, sans-serif; font-size: 14px; line-height: 1.3em;">Что это такое?</span></p>
<p>WebDriverFactory — это библиотека, которая помогает управлять запущенными экземплярами WebDriver (ну и браузерами тоже, поскольку каждому экземпляру драйвера соответствует свой экземпляр браузера).</p>
<p>Цель: предоставить пользователям инструмент, который умеет</p>
<ul>
<li><span style="line-height: 1.3em;">автоматически создавать драйвер (и запускать браузер) по требованию в момент первого использования,</span></li>
<li><span style="line-height: 1.3em;">повторно использовать уже созданные драйверы, если есть такая возможность,</span></li>
<li><span style="line-height: 1.3em;">автоматически останавливать старый и запускать новый, когда понадобился драйвер с другими характеристиками,</span></li>
<li><span style="line-height: 1.3em;">автоматически запускать нового драйвера, если предыдущий экземпляр недоступен,</span></li>
<li><span style="line-height: 1.3em;">останавливать все запущенные драйверы одной командой.</span></li>
</ul>
<p><span style="line-height: 1.3em;">По сравнению с тем, что было описано в предыдущей статье, я отказался от следующих «сомнительных фич»</span></p>
<ul>
<li><span style="line-height: 1.3em;">автоматический перезапуск драйвера после заданного количества использований — раньше это было актуально, когда у браузера Firefox наблюдались серьёзные утечки памяти, сейчас эта «фича» уже практически невостребована, а если очень нужно — её можно реализовать при помощи несложного счётчика на уровне конфигурацинных методов тестового набора (@Before)</span></li>
<li><span style="line-height: 1.3em;">автоматический останов всех драйверов при завершении работы виртуальной машины Java — эта фича осталась, но её не рекомендуется использовать, потому что с некоторыми браузерами возникают проблемы именно при остановке их из shutdown hook, так что лучше явно в конце выполнять остановку всех драйверов специальной командой.</span></li>
</ul>
<p><span style="line-height: 1.3em;">(Вообще говоря, название «фабрика» (Factory) не совсем правильное, потому что эта библиотека реализует шаблон проектирования, который больше похож на <a href="http://sourcemaking.com/design_patterns/object_pool">Object Pool</a>, но я решил оставить сложившееся исторически название, потому что и «пул» тоже является одной из вариаций общей концепции <a href="http://en.wikipedia.org/wiki/Factory_(software_concept)">Factory</a>).</span></p>
<h2>Как подключить библиотеку к проекту?</h2>
<p>Если вы используете Maven — достаточно просто добавить зависимости от фабрики и от самой библиотеки Selenium:</p>
<pre>&lt;dependency&gt;<br />  &lt;groupId&gt;ru.stqa.selenium&lt;/groupId&gt;<br />  &lt;artifactId&gt;webdriver-factory&lt;/artifactId&gt;<br />  &lt;version&gt;2.0&lt;/version&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />  &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;<br />  &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;<br />  &lt;version&gt;2.53.0&lt;/version&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />  &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;<br />  &lt;artifactId&gt;selenium-server&lt;/artifactId&gt;<br />  &lt;version&gt;2.53.0&lt;/version&gt;<br />&lt;/dependency&gt;<span style="line-height: 1.3em;"> </span></pre>
<p><span style="font-size: 12.16px; line-height: 1.3em;"><span style="font-size: 12.16px; line-height: 1.3em;">Номер последней доступной версии смотрите в центральном </span><a href="http://search.maven.org/#browse%7C-716647851" style="font-size: 12.16px; line-height: 1.3em;">репозитории Maven</a><span style="font-size: 12.16px; line-height: 1.3em;">.</span></span></p>
<p>Если вы не используете Maven — тогда оттуда же из центрального репозитория нужно скачать jar-файл webdriver-factory-2.0.jar (номер версии может быть другим, конечно) и подключить его к вашему проекту так, как вы подключаете другие jar-файлы.</p>
<h2>Как это работает?</h2>
<p>Фабрика имеет два основных режима работы:</p>
<ul>
<li><span style="line-height: 1.3em;">SINGLETON — в каждый момент времени может существовать не более одного экземпляра WebDriver, управляемого фабрикой</span></li>
<li><span style="line-height: 1.3em;">THREADLOCAL_SINGLETON — в каждый момент времени в каждом потоке может существовать не более одного экземпляра WebDriver, управляемого фабрикой</span></li>
</ul>
<p><span style="line-height: 1.3em;">По умолчанию используется режим работы THREADLOCAL_SINGLETON. </span><span style="font-size: 12.16px; line-height: 1.3em;">Режимы работы можно переключать, если нет ни одного запущенного драйвера:</span></p>
<pre>WebDriverFactory.setMode(WebDriverFactoryMode.SINGLETON);</pre>
<h3>Режим работы SINGLETON</h3>
<p>Давайте рассмотрим, как работает вот такой сценарий:</p>
<pre>// 1. первый запрос на получение драйвера<br />Capabilities firefox = DesiredCapabilities.firefox();<br />WebDriver driver = WebDriverFactory.getDriver(firefox);<br />// 2. второй запрос на получение драйвера, с теми же характеристиками<br />driver = WebDriverFactory.getDriver(firefox);<br />// 3. третий запрос на получение драйвера, с другими характеристиками<br />Capabilities chrome = DesiredCapabilities.chrome();<br />driver = WebDriverFactory.getDriver(chrome);<br />// 4. остановка драйвера<br />WebDriverFactory.dismiss(driver);</pre>
<ol>
<li><span style="line-height: 1.3em;">При первом запросе запускается новый драйвер (и новый браузер).</span></li>
<li><span style="line-height: 1.3em;">При втором запросе, поскольку требуется драйвер с теми же характеристиками, возвращается ранее запущенный драйвер.</span></li>
<li><span style="line-height: 1.3em;">При третьем запросе, поскольку требуется драйвер с другими характеристиками, предыдущий драйвер автоматически останавливается, и вместо него запускается новый, с запрашиваемыми характеристиками.</span></li>
<li><span style="line-height: 1.3em;">Метод dismiss останавливает единственный существующий драйвер.</span></li>
</ol>
<h3><span style="line-height: 1.3em;">Режим работы THREADLOCAL_SINGLETON</span></h3>
<p>Этот режим работы необходим при параллельном выполнении тестов в нескольких потоках, чтобы избежать конфликтов. Он работает аналогично предыдущему, но только для каждого потока проверки выполняются независимо.</p>
<p>То есть если весь вышеуказанный код выполняется в одном и том же потоке — всё будет работать точно так же, как описано в предыдущем разделе: сначала запускается новый драйвер, потом он повторно используется, потом он останавливается и вместо него запускается драйвер с другими характеристиками, и наконец этот последний драйвер останавливается.</p>
<p>Но если тесты работают в нескольких параллельно выполняющихся потоках, то второй запрос драйвера с теми же характеристиками может случиться в другом потоке, и тогда будет создан новый драйвер, несмотря на то, что драйвер с нужными характеристиками уже есть. У каждого потока свой драйвер, использовать драйвер другого потока фабрика не позволит.</p>
<p>Аналогично, если потребовался драйвер с другими характеристиками — он будет запущен, но остановлен при этом может быть только драйвер, который ранее был запущен в том же самом потоке. Драйверы, принадлежащие другим потокам, останутся нетронутыми.</p>
<h2>Чем ещё полезна фабрика?</h2>
<p>Есть у фабрики ещё пара полезных функций, помимо хранения драйверов для повторного использования и их автоматического перезапуска.</p>
<p>Перед тем, как вернуть клиенту существующий драйвер, фабрика проверяет, что он функционирует нормально — вызывает метод getCurrentUrl(). Если этот метод отработает успешно — фабрика вернёт клиенту этот ранее запущенный драйвер. Но если возникают проблемы, драйвер считается «испорченным», в этом случае фабрика запустит новый и вернёт его. В любом случае, клиент получит старый или новый, но работающий драйвер, удовлетворяющий заданным характеристикам.</p>
<p>Кроме того, поскольку фабрика хранит все запущенные драйверы, она позволяет в конце остановить все оставшиеся активные драйверы одной командой dismissAll():</p>
<pre>@AfterSuite<br />public void stopAllDrivers() {<br />  WebDriverFactory.dismissAll();<br />}</pre>
<p>В проекте на GitHub можно посмотреть <a href="https://github.com/barancev/webdriver-factory-samples/tree/master/src/test/java/ru/stqa/selenium/factory/samples">примеры использования фабрики</a> с тестовыми фреймворками JUnit и TestNG.</p>
<h2>Будет ли продолжение?</h2>
<p>Возможно, в будущем появятся новые режимы работы фабрики, накладывающие меньше ограничений и ориентированные на удалённый запуск с использованием Selenium Grid. Но с концептуальной точки зрения я считаю для себя тему запуска браузеров закрытой. Впрочем, я буду рад ошибиться. Если есть какие-то идеи развития — <a href="https://github.com/barancev/webdriver-factory/">присылайте пулл-реквесты</a>!</p>
